---
title: Better Auth Setup
description: Configure Better Auth with Next.js and social providers
---

## Problem

Setting up authentication in Next.js requires handling sessions, OAuth providers, database storage, and middleware protection. Better Auth provides a type-safe solution but requires proper configuration for both server and client.

## Solution

Configure Better Auth with Drizzle ORM for database storage, social providers for OAuth (conditionally enabled via env vars), and middleware for route protection. Use cookie caching for performance and proper session handling across server components, client components, and API routes.

## Implementation

### Files

```
lib/
  auth.ts              # Server-side auth configuration
  auth-client.ts       # Client-side auth hooks
  db/
    schema.ts          # Auth tables (user, session, account)

providers/
  session-provider.tsx # React context for session state

app/
  api/auth/[...all]/
    route.ts           # Auth API route handler

middleware.ts          # Route protection
```

### Server Configuration

```ts title="lib/auth.ts"
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { nextCookies } from "better-auth/next-js";
import { env } from "@/lib/env";
import { db } from "./db/client";
import { schema } from "./db/schema";
import { config } from "@/lib/config/index";

export const auth = betterAuth({
  database: drizzleAdapter(db, {
    provider: "pg",
    schema,
  }),
  trustedOrigins: [
    "http://localhost:3000",
    // Vercel URL for preview branches
    ...(env.VERCEL_URL ? [`https://${env.VERCEL_URL}`] : []),
    config.appUrl,
  ],
  secret: env.AUTH_SECRET,

  session: {
    cookieCache: {
      enabled: true,
      maxAge: 60 * 5, // 5 minutes - reduces database queries
    },
  },

  // Social providers are conditionally enabled based on env vars
  socialProviders: (() => {
    const googleId = env.AUTH_GOOGLE_ID;
    const googleSecret = env.AUTH_GOOGLE_SECRET;
    const githubId = env.AUTH_GITHUB_ID;
    const githubSecret = env.AUTH_GITHUB_SECRET;
    const vercelId = env.VERCEL_APP_CLIENT_ID;
    const vercelSecret = env.VERCEL_APP_CLIENT_SECRET;

    const google =
      typeof googleId === "string" &&
      googleId.length > 0 &&
      typeof googleSecret === "string" &&
      googleSecret.length > 0
        ? { clientId: googleId, clientSecret: googleSecret }
        : undefined;

    const github =
      typeof githubId === "string" &&
      githubId.length > 0 &&
      typeof githubSecret === "string" &&
      githubSecret.length > 0
        ? { clientId: githubId, clientSecret: githubSecret }
        : undefined;

    const vercel =
      typeof vercelId === "string" &&
      vercelId.length > 0 &&
      typeof vercelSecret === "string" &&
      vercelSecret.length > 0
        ? { clientId: vercelId, clientSecret: vercelSecret }
        : undefined;

    return { google, github, vercel } as const;
  })(),
  plugins: [nextCookies()],
});

export type Session = typeof auth.$Infer.Session;
```

### Client Configuration

```ts title="lib/auth-client.ts"
import { nextCookies } from "better-auth/next-js";
import { createAuthClient } from "better-auth/react";

// Better Auth auto-detects the base URL from window.location.origin on client
// and uses relative URLs for SSR, so we don't need to specify baseURL
const authClient = createAuthClient({
  plugins: [nextCookies()],
});

export default authClient;
```

<Note>
  The `nextCookies()` plugin is required on both server and client for proper
  cookie handling in Next.js Server Actions.
</Note>

### API Route Handler

```ts title="app/api/auth/[...all]/route.ts"
import { auth } from "@/lib/auth";
import { toNextJsHandler } from "better-auth/next-js";

export const { GET, POST } = toNextJsHandler(auth.handler);
```

### Session Provider

```tsx title="providers/session-provider.tsx"
"use client";

import { createContext, useContext, type ReactNode } from "react";
import { useSession as useBetterAuthSession } from "@/lib/auth-client";
import type { Session } from "@/lib/auth";

type SessionContextValue = {
  data: Session | null;
  isPending: boolean;
};

const SessionContext = createContext<SessionContextValue | null>(null);

export function SessionProvider({
  children,
  initialSession,
}: {
  children: ReactNode;
  initialSession: Session | null;
}) {
  const { data, isPending } = useBetterAuthSession();

  // Use initial session for SSR, then hydrate with client state
  const value = {
    data: data ?? initialSession,
    isPending,
  };

  return (
    <SessionContext.Provider value={value}>{children}</SessionContext.Provider>
  );
}

export function useSession() {
  const context = useContext(SessionContext);
  if (!context) {
    throw new Error("useSession must be used within SessionProvider");
  }
  return context;
}
```

### Database Schema

```ts title="lib/db/schema.ts"
import { pgTable, text, timestamp, boolean } from "drizzle-orm/pg-core";

export const user = pgTable("user", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  emailVerified: boolean("email_verified").notNull().default(false),
  image: text("image"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export const session = pgTable("session", {
  id: text("id").primaryKey(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  token: text("token").notNull().unique(),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export const account = pgTable("account", {
  id: text("id").primaryKey(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  accountId: text("account_id").notNull(),
  providerId: text("provider_id").notNull(),
  accessToken: text("access_token"),
  refreshToken: text("refresh_token"),
  expiresAt: timestamp("expires_at"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export const verification = pgTable("verification", {
  id: text("id").primaryKey(),
  identifier: text("identifier").notNull(),
  value: text("value").notNull(),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});
```

### Middleware Protection

```ts title="middleware.ts"
import { NextResponse, type NextRequest } from "next/server";
import { auth } from "@/lib/auth";

const publicRoutes = ["/", "/login", "/register", "/api/auth"];

function isPublicRoute(pathname: string) {
  return publicRoutes.some(
    (route) => pathname === route || pathname.startsWith(`${route}/`)
  );
}

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  // Skip public routes
  if (isPublicRoute(pathname)) {
    return NextResponse.next();
  }

  // Validate session
  const session = await auth.api.getSession({
    headers: request.headers,
  });

  if (!session?.user) {
    const loginUrl = new URL("/login", request.url);
    loginUrl.searchParams.set("callbackUrl", pathname);
    return NextResponse.redirect(loginUrl);
  }

  return NextResponse.next();
}

export const config = {
  matcher: ["/((?!_next/static|_next/image|favicon.ico).*)"],
};
```

## Usage

### Server-Side Session

```ts
import { headers } from "next/headers";
import { auth } from "@/lib/auth";

// In Server Components, API routes, or Server Actions
const session = await auth.api.getSession({
  headers: await headers(),
});

if (session?.user) {
  const userId = session.user.id;
}
```

### Client-Side Session

```tsx
import { useSession } from "@/providers/session-provider";

function ProfileButton() {
  const { data: session, isPending } = useSession();

  if (isPending) return <Skeleton />;
  if (!session?.user) return <LoginButton />;

  return <span>Welcome, {session.user.name}</span>;
}
```

### Sign In / Sign Out

```tsx
import authClient from "@/lib/auth-client";

// Social sign-in
await authClient.signIn.social({
  provider: "google", // or "github", "vercel"
});

// Sign out
await authClient.signOut();
window.location.href = "/";
```

### Layout with Session Provider

```tsx title="app/layout.tsx"
import { headers } from "next/headers";
import { auth } from "@/lib/auth";
import { SessionProvider } from "@/providers/session-provider";

export default async function RootLayout({ children }) {
  const session = await auth.api.getSession({
    headers: await headers(),
  });

  return (
    <html>
      <body>
        <SessionProvider initialSession={session}>{children}</SessionProvider>
      </body>
    </html>
  );
}
```

## Considerations

**Performance:**

- Cookie caching reduces database queries but revoked sessions persist for `maxAge` seconds
- Use `initialSession` prop for SSR hydration to avoid layout shift

**Security:**

- Always use HTTPS in production
- Keep `AUTH_SECRET` secure and random
- Use `trustedOrigins` to prevent CSRF attacks

**Adding Providers:**

1. Get OAuth credentials from provider (Google Cloud Console, GitHub Developer Settings, Vercel Integrations, etc.)
2. Add environment variables to `lib/env.ts`
3. Enable the provider in `chat.config.ts`
4. Add login button to your UI (see `components/social-auth-providers.tsx`)
